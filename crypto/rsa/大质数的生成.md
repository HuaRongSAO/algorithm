# RSA公钥密码算法中大素数的生成及素性检测
在RSA算法生成的时候,大质数q,和p的生成和检查就变得尤为重要.

具体步骤:
- 准备一个小质数表,最好2000个以上,越多越好 ---(1)
- 随机生成一个大数N,在生成的时候,一颗采用2进制,然后确保高位是1(目的:确保生成的大数符合你要的位数),最低位1(目的:确保生成的数是奇数) ---(2)
- 用N遍历 (1) 里的大质数表,能整除就重复第(2)步 ---(3)
- 对N进行Miller-Rabin素性检验，8次。如果N没有通过检验，回到第(2)步。否则认为X是素数。---(4)
- 用上述步骤得到的p，q，生成密钥对，e预先定义为0x10001。随机生成一个数，进行加密解密，比对结果。 ---(5)


### Miller-Rabin素数检测算法

#### 理论基础：

1. 费马小定理：假如p是质数，a是整数，且a、p互质，那么a的(p-1)次方除以p的余数恒等于1，即：a^(p-1) ≡ 1 ( mod p). 但是反过来却不一定成立，就是说，如果a、p互质，且a^(p-1)≡1(mod p)，不能推出p是质数
2. 二次探测定理：如果p是一个素数，0 < x < p,则方程 x^2 ≡ 1(mod p)的解为x=1 或 x=p-1。
3. 模运算的规则：( a * b ) mod n = (a mod n * b modn) mod n
4. 快速积取模
  - (a * b) mod p = (a mod p * b mod p) mod p
5. 快速幂取模
  -  a ^ b mod p = ((a mod p)^b) mod p

#### 算法过程
然后是算法的过程：对于要判断的数n

1. 先判断是不是2，是的话就返回true。

2. 判断是不是小于2的，或合数，是的话就返回false。

3. 令n-1=u*2^t，求出u，t，其中u是奇数。

4. 随机取一个a,且1 < a < n .
   - 根据费马小定理，如果a^(n-1) ≡ 1(mod p)那么n就极有可能是素数，如果等式不成立，那肯定不是素数了因为n-1 = u * 2^t，所以a^(n-1) = a^(u * 2^t )=( a^u )^( 2^t )

5. 所以我们令x=(a^u) mod n

6. 然后是t次循环，每次循环都让y=( x * x ) mod n, x = y, 这样t次循环之后 x = a^( u*2^t ) = a^( n-1 )了

7. 因为循环的时候y=(x*x) mod n，且x肯定是小于n的，正好可以用二次探测定理，
如果(x^2) mod n == 1，也就是y等于1的时候，假如n是素数，那么x==1||x==n-1，如果x!=1&&x!=n-1，那么n肯定不是素数了，返回false。

8. 运行到这里的时候x=a^(n-1)，根据费马小定理，x!=1的话，肯定不是素数了，返回false

9. 因为Miller-Rabin得到的结果的正确率为 75%，所以要多次循环步骤4~8来提高正确率,这里进行循环8次，8次都通过则素数的概率为0.9999847

10. 循环多次之后还没返回，那么n肯定是素数了，返回true

#### 模运算
  - 补充模运算规则
  - 模运算加减法：
    1. (a + b) mod p = (a mod p + b mod p) mod p
    2. (a - b) mod p = (a mod p - b mod p) mod p
  - 模运算乘法：
    1. (a * b) mod p = (a mod p * b mod p) mod p
  - 模运算幂
    1. a ^ b mod p = ((a mod p)^b) mod p